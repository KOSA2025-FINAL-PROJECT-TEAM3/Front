# 채팅 숫자 1이 자꾸 사라지는 문제, 어떻게 고쳤을까? (초보자용 가이드)

## 1. 무슨 문제가 있었나요?

우리가 가족 채팅방(3명)을 쓰고 있을 때, 아주 이상한 일이 벌어졌습니다.

1.  **나 혼자 있을 때:** 아무 문제 없음.
2.  **다른 가족(B)이 들어왔을 때:** 내가 채팅을 칠 때마다 **옛날 메시지의 노란 숫자(안 읽은 사람 수)가 자꾸 1씩 줄어듦!**
3.  **새로고침하면:** 다시 원래대로 숫자가 돌아옴.

마치 **"이미 읽었다고 계산된 메시지를, 컴퓨터가 까먹고 또 읽었다고 쳐서 숫자를 깎아먹는"** 상황이었죠.

---

## 2. 왜 이런 일이 벌어졌을까요? (범인은 '기억 상실')

### 상황극으로 알아보기

1.  **서버(은행원):** (새로고침 했을 때) "자, 여기 옛날 메시지들입니다. 안 읽은 사람은 1명 남았어요." (숫자 `1`을 줌)
2.  **내 앱(프론트엔드):** "넵, 숫자 1 표시했습니다!"
3.  **상대방 B:** (채팅방에 들어와 있음) "나 방금 올라온 새 글 읽었어!" (신호를 보냄)
4.  **내 앱:** "어? B가 글을 읽었네? B는 안 읽은 사람 1명 중 한 명이겠지? 그럼 숫자를 깎아야지!" -> **숫자 `0`이 됨.**

### 진짜 문제점
사실 서버가 처음에 준 숫자 `1`은 **이미 B가 읽은 걸 뺀 숫자**였습니다. (남은 1명은 안 들어온 C)
그런데 내 앱은 **"새로고침해서 기억이 리셋된 상태"**라, B가 읽었는지 안 읽었는지 몰랐던 겁니다.
그래서 B가 "나 활동 중이야!"라고 신호를 보내자, "어? 너 안 읽었었니? 그럼 깎아!" 하고 **중복으로 깎아버린 것**이죠.

---

## 3. 어떻게 해결했나요? (해결책: 눈치 챙기기)

우리는 앱에게 **"눈치"**를 줬습니다.

**"야, 새로고침하고 나서 처음 신호를 보낸 사람이, 뜬금없이 옛날 글이 아니라 '가장 최신 글'을 읽었다고 하면, 그 사람은 원래부터 다 읽고 있던 사람이야. 그러니까 숫자를 깎지 마!"**

### 수정한 코드 설명

우리는 `FamilyChatConversationPage.jsx` 파일에 **탐정(Logic)**을 심었습니다.

#### 1단계: 탐정 수첩 만들기 (`useRef`)
누가 신호를 보냈는지 기록할 수첩을 하나 만들었습니다.
```javascript
// 수첩: 이미 신호를 보낸 사람들의 명단
const processedReadSendersRef = useRef(new Set());
```

#### 2단계: 신호가 왔을 때 추리하기 (`connectWebSocket`)

누군가(B)에게서 **"나 읽었어!"** 신호가 오면 이렇게 생각합니다.

1.  **"B가 이 수첩에 있나?"**
    *   없다면 -> "오늘 처음 신호 보낸 거네?"
2.  **"B가 읽은 글이 가장 최신 글인가?"**
    *   맞다면 -> "아하! B는 방금 들어온 게 아니라, 아까부터 쭉 보고 있었구나!" (**기존 독자**)
3.  **조치 취하기**
    *   **기존 독자라면:** 숫자를 **깎지 않습니다.** (이미 깎여있을 테니까요) 대신, 다음번에 또 헷갈리지 않게 "B는 읽음" 도장만 찍어둡니다.
    *   **새로운 독자라면:** (예: 아주 옛날 글을 읽었다고 함) 진짜로 안 읽었던 사람이니 숫자를 **깎습니다.**

### 실제 적용된 코드 (주석 포함)

```javascript
setMessages(prevMessages => {
    // 1. 수첩에 B(senderId)가 없는지 확인 (첫 신호인가?)
    const isFirstEventFromSender = !processedReadSendersRef.current.has(senderId);
    
    // 2. 현재 화면의 가장 마지막(최신) 메시지 번호 확인
    const latestMsgId = prevMessages.length > 0 ? prevMessages[prevMessages.length - 1].id : 0;
    
    // 3. 추리: 첫 신호인데, 읽은 위치가 최신 글이랑 같다면? -> "원래 다 읽고 있던 사람(Existing Reader)"이다!
    const isExistingReader = isFirstEventFromSender && (readMessageId >= latestMsgId);

    // 수첩에 B 이름 적기 (다음부터는 '첫 신호'가 아니게 됨)
    if (isFirstEventFromSender) {
        processedReadSendersRef.current.add(senderId);
    }

    return prevMessages.map(m => {
        // ... (중략) ...

        // 🔥 여기가 핵심!
        // 원래 다 읽고 있던 사람(isExistingReader)이라면?
        if (isExistingReader) {
            // 숫자는 깎지 말고(unreadCount - 1 안 함), 도장만 찍어서 돌려보냄
            return {
                ...m,
                readBy: [...readBy, senderId]
            };
        }

        // 그게 아니면(진짜 안 읽은 사람이면) 숫자를 깎음!
        return { 
            ...m, 
            unreadCount: m.unreadCount - 1, // 🔻 숫자 감소
            readBy: [...readBy, senderId]
        };
    });
});
```

---

## 4. 결과

이제 3명이 있든 10명이 있든:
1.  새로고침해도 숫자가 정확하게 나옵니다.
2.  내가 채팅을 쳐도 숫자가 맘대로 줄어들지 않습니다.
3.  진짜 안 읽은 사람(C)이 들어와서 읽을 때만 숫자가 딱 줄어듭니다.

**완벽하게 고쳐졌습니다!** 🎉
