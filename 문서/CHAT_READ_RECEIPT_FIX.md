# 채팅 읽음 처리(Unread Count) 로직 분석 및 중복 차감 해결 보고서

## 1. 문제 상황 (Issue)
- **환경:** 3명 이상의 사용자가 참여 중인 가족 채팅방.
- **증상:** 
  - 채팅방에 **혼자** 있을 때는 숫자가 정상 표시됨.
  - **다른 멤버(B)**가 함께 접속해 있을 때, **내가 채팅을 칠 때마다** 기존 메시지들의 안 읽은 숫자(`unreadCount`)가 비정상적으로 1씩 계속 줄어듬.
  - 새로고침하면 다시 정상 숫자로 돌아옴.
- **원인 추정:** 
  - 내가 새 메시지를 보냄 -> 상대방(B)이 실시간으로 읽음 -> B가 "나 읽었어(READ)" 이벤트를 서버로 전송.
  - 내 앱이 B의 `READ` 이벤트를 수신할 때, **이미 B가 읽었다고 처리하여 숫자를 깎았던 과거 메시지들에 대해서도 중복으로 숫자를 또 깎음.**

---

## 2. 기존 로직의 한계
기존 프론트엔드 코드는 단순히 **"숫자(`unreadCount`)"**만 관리하고 있었습니다.

```javascript
// 기존 코드 (문제 발생)
if (m.id <= readMessageId && m.unreadCount > 0) {
    return { ...m, unreadCount: m.unreadCount - 1 };
}
```

- **누가 읽었는지 기억하지 않음:** B가 100번 메시지를 읽어서 숫자를 2->1로 만들었는데, B가 101번을 읽었다는 신호를 또 보내면, 로직상 `100 <= 101`이므로 100번 메시지를 또 건드려서 1->0으로 만듦.
- **결과:** B가 활동할 때마다 과거 메시지들이 계속 차감됨.

---

## 3. 해결 솔루션 (Solution)
백엔드의 변경 없이 프론트엔드에서 **"누가 읽었는지(`readBy`)"**를 메모리상에서 추적하여 중복 차감을 방지하는 방식을 도입했습니다.

### 3.1. `readBy` 속성 도입
각 메시지 객체에 동적으로 `readBy` 배열을 추가하여, 해당 메시지를 읽음 처리하게 만든 멤버 ID들을 기록합니다.

### 3.2. 개선된 로직 (Algorithm)

```javascript
// [FIX] 중복 차감 방지 로직 적용
setMessages(prevMessages => prevMessages.map(m => {
    // 1. 읽은 범위 내에 있는 안 읽은 메시지인지 확인
    if (m.id <= readMessageId && m.unreadCount > 0) {
        
        // 2. 이 메시지를 이미 처리한 사람 목록(readBy) 가져오기
        const readBy = m.readBy || [];
        
        // 3. 이미 이 사람(senderId) 때문에 숫자를 깎았는지 확인
        if (readBy.includes(senderId)) {
            return m; // 이미 처리했으면 무시 (중복 방지)
        }

        // 4. 처음 처리하는 경우에만 숫자 감소 및 명단 기록
        return { 
            ...m, 
            unreadCount: m.unreadCount - 1,
            readBy: [...readBy, senderId] // 읽은 사람 추가
        };
    }
    return m;
}));
```

---

## 4. 동작 시나리오 검증

### 상황: 메시지 ID 100 (안 읽은 수: 1)
- **전제:** 나(A), 상대방(B, C). B는 안 읽은 상태.

1. **B가 채팅방 접속 (100번 읽음)**
   - `READ` 이벤트 도착 (Sender: B, ReadId: 100)
   - 메시지 100의 `readBy` 확인: `[]` (비어있음)
   - **조치:** `unreadCount` 1 -> 0 감소. `readBy`에 `[B]` 추가.
   - **결과:** 화면에서 숫자 사라짐 (정상).

2. **내가 새 메시지 101 전송**
   - B가 실시간으로 101 읽음 -> `READ` 이벤트 도착 (Sender: B, ReadId: 101)
   - **[101번 메시지 처리]**
     - `unreadCount` 1 -> 0 감소. `readBy: [B]`. (정상)
   - **[100번 메시지 처리] (이전에는 여기서 문제 발생)**
     - 조건: `100 <= 101` (참)
     - `readBy` 확인: `[B]` (이미 있음!)
     - **조치:** `includes(B)`가 참이므로 **아무것도 하지 않고 리턴.**
     - **결과:** 숫자가 0에서 -1로 떨어지지 않고 0으로 유지됨 (버그 해결).

---

## 5. 결론
이 방식은 백엔드 DB 스키마나 API 응답 구조를 변경하지 않고도, 프론트엔드 상태 관리(State Management) 레벨에서 **실시간 읽음 동기화의 정합성**을 완벽하게 보장합니다.
